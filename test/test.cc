/*
 *  $Id: test.cc,v 1.2 1998/12/09 03:01:02 sbooth Exp $
 *
 *  Copyright (C) 1996, 1997, 1998 Stephen F. Booth
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Library General Public
 *  License as published by the Free Software Foundation; either
 *  version 2 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Library General Public License for more details.
 *
 *  You should have received a copy of the GNU Library General Public
 *  License along with this library; if not, write to the Free
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

#include "HTMLClasses.hh"
#include "Cgicc.hh"
#include "Exception.hh"

#if HAVE_UNAME
#include <sys/utsname.h>
#endif

#if HAVE_SYS_TIME_H
#include <sys/time.h>
#endif

#include <stdlib.h>

// To use logging, the variable gLogFile MUST be defined, and it _must_
// be an ofstream
#if DEBUG
ofstream gLogFile( "/usr/home/sbooth/public_html/Cgicc.log", ios::app );
#endif

// Function prototypes
void dumpEnvironment(const CgiEnvironment *env);
void dumpList(const Cgicc *formData);
void showForm(const Cgicc *formData);
void showFile(const Cgicc *formData);

// Main Street, USA
int
main(int argc, char **argv)
{
  try {
#if HAVE_GETTIMEOFDAY
    timeval start;
    gettimeofday(&start, NULL);
#endif

    // Create a new Cgicc object containing all the CGI data
    Cgicc cgi;
    
    // If the user wants to throw an Exception, go ahead and do it
    if(cgi.queryCheckbox("throw") && ! cgi.queryCheckbox("restore"))
      throw Exception("User-requested Exception thrown in main()", ERRINFO);
    
    // Output the HTTP headers for an HTML document, and the HTML 4.0 DTD info
    cout << HTTPHTMLHeader() << HTMLDoctype(HTMLDoctype::eStrict) << endl;
    cout << html(add("lang","EN").add("dir","LTR")) << endl;

    // Set up the page's header and title.
    // I will put in lfs to ease reading of the produced HTML. 
    cout << head() << endl;
    cout << title() << "Cgicc v" << cgi.getCgiccVersion() << " Test Results" 
	 << title() << endl;
    cout << meta(add("name", "author")
		 .add("content", "Stephen F. Booth")) << endl;
    cout << link_(add("href","/~sbooth/cgicc.css")
		  .add("rel","stylesheet").add("type","text/css")) << endl;
    cout << head() << endl;
    
    // Start the HTML body
    cout << body() << endl;
    
    cout << h1() << "Cgi" << span("cc", add("class","red"))
	 << " v"<< cgi.getCgiccVersion() << " Test Results" << h1() << endl;
    
    // Get a pointer to the environment
    const CgiEnvironment *env = cgi.getEnvironment();
    
    // Generic thank you message
    cout << comment() << "This page generated by Cgicc for "
	 << env->getRemoteHost() << comment() << endl;
    cout << h4() << "Thanks for using Cgi" << span("cc", add("class", "red")) 
	 << ", " << env->getRemoteHost() << '!' << h4() << endl;  
    
    // If the user wants to save the submission, do it
    if(cgi.queryCheckbox("save")) {
      cgi.save("save");
      cout << p(h2("Data Saved")) << endl;
      
      cout << div_(add("class", "notice")) << endl;
      cout << "Your data has been saved, and may be restored (by anyone) "
	   << "via the same form." << endl << div_() << p() << endl;
    }
    
    // If the user wants to restore from the last submission, do it
    if(cgi.queryCheckbox("restore")) {
      cgi.restore("save");
      cout << p(h2("Data Restored")) << endl;
      
      cout << div_(add("class", "notice")) << endl;
      cout << "The data displayed has been restored from a file on disk."
	   << endl << div_() << p() << endl;
    }
    
    // If the user requested a dump of the environment,
    // create a simple table showing the values of the 
    // environment variables
    if(cgi.queryCheckbox("showEnv"))
      dumpEnvironment(env);
    
    // If the user requested, print out the raw form data from 
    // the LinkedList of FormEntries.  This will contain every 
    // element in the list.
    // This is one of two ways to get at form data, the other
    // being the use of Cgicc's getElement() methods.  
    if(cgi.queryCheckbox("showFE"))
      dumpList(&cgi);
    
    // If the user requested data via Cgicc's getElement() methods, do it.
    // This is different than the use of the list of FormEntries 
    // because it requires prior knowledge of the name of form elements.
    // Usually they will be known, but you never know.
    if(cgi.queryCheckbox("showForm"))
      showForm(&cgi);

    // If the user requested information on the uploaded file,
    // create a simple table showing the information
    // Disabled for demo
    if(cgi.queryCheckbox("showFile"))
      showFile(&cgi);

    // Now print out a footer with some fun info
    cout << div_(add("align","center"));
    cout << p() << "You may view the ";
    cout << a("source code", add("href","/~sbooth/test.cc"));
    cout << " of this application." << p() << endl;
    
    // Toolbar
    cout << a("Back to form", add("href","/~sbooth/testform.html")) 
	 << " | "
	 << a("Cgicc Documentation", add("href","/~sbooth/index.html"))
	 << " | " 
	 << a("Alphabetic Index of Classes", 
	      add("href","/~sbooth/aindex.html"))
	 << " | " 
	 << a("Class Hierarchy",add("href","/~sbooth/HIER.html")) 
	 << endl;
    cout << div_() << br() << hr(add("class","half")) << endl;
    
    // Information on Cgicc
    cout << div_(add("align","center").add("class","smaller")) << endl;
    cout << "Cgi" << span("cc", add("class","red")) << " v";
    cout << cgi.getCgiccVersion();
    cout << " by " << a("Stephen F. Booth", 
			add("href", "http://www.lmi.net/~sbooth/")) << br();
    cout << "Compiled at " << cgi.getCompileTime();
    cout << " on " << cgi.getCompileDate();

#if HAVE_UNAME
    struct utsname info;
    if(uname(&info) != -1) {
      cout << ". Running on " << info.sysname;
      cout << ' ' << info.release << " (";
      cout << info.nodename << ")." << endl;
    }
#else
    cout << "." << endl;
#endif

#if HAVE_GETTIMEOFDAY
    // Information on this query
    timeval end;
    gettimeofday(&end, NULL);
    long us = ((end.tv_sec - start.tv_sec) * 1000000)
      + (end.tv_usec - start.tv_usec);

    cout << br() << "Total time for request = " << us << " us";
    cout << " (" << (double) (us/1000000.0) << " s)";
#endif

    // End of document
    cout << div_() << endl;
    cout << body() << html() << endl;

    // No chance for failure in this example
    return EXIT_SUCCESS;
  }

  // Did any errors occur?
  catch(const Exception& e) {

    // This is a dummy exception handler, as it doesn't really do
    // anything except print out information.

    // Reset all the HTML elements that might have been used to 
    // their initial state so we get valid output
    html::reset(); 	head::reset(); 		body::reset();
    title::reset(); 	h1::reset(); 		h4::reset();
    comment::reset(); 	td::reset(); 		tr::reset(); 
    table::reset();	div_::reset(); 		p::reset(); 
    a::reset();		h2::reset(); 		colgroup::reset();

    // Output the HTTP headers for an HTML document, and the HTML 4.0 DTD info
    cout << HTTPHTMLHeader() << HTMLDoctype(HTMLDoctype::eStrict) << endl;
    cout << html(add("lang","EN").add("dir","LTR")) << endl;

    // Set up the page's header and title.
    // I will put in lfs to ease reading of the produced HTML. 
    cout << head() << endl;
    cout << title("Cgicc Exception") << endl;
    cout << meta(add("name", "author")
		 .add("content", "Stephen F. Booth")) << endl;
    cout << link_(add("href","/~sbooth/cgicc.css")
		  .add("rel","stylesheet").add("type","text/css")) << endl;
    cout << head() << endl;
    
    cout << body() << endl;
    
    cout << h1() << "Cgi" << span("cc", add("class","red"))
	 << " caught an " 
	 << a("Exception", add("HREF", "/~sbooth/Exception.html"))
	 << h1() << endl;
  
    cout << div_(add("align","center")) << endl;
  
    cout << table(add("border","0").add("rules","none").add("frame","void")
		  .add("cellspacing","2").add("cellpadding","2")
		  .add("class","cgi")) << endl;
    cout << colgroup(add("span","2")) << endl;
    cout << col(add("align","center").add("class","title").add("span","1")) 
	 << endl;
    cout << col(add("align","left").add("class","data").add("span","1")) 
	 << endl;
    cout << colgroup() << endl;
    
    cout << tr() << td("Message", add("class","title")) 
	 << td(e.getMessage(), add("class","data")) << tr() << endl;
    cout << tr() << td("File", add("class","title")) 
	 << td(e.getFile(), add("class","data")) << tr() << endl;
    cout << tr() << td("Line", add("class","title")) 
	 << td(add("class","data")) << e.getLine() << td() << tr() << endl;

    cout << table() << div_() << endl;
    
    // Now print out a footer with some fun info
    cout << div_(add("align","center"));
    cout << p() << "You may view the ";
    cout << a("source code", add("href","/~sbooth/test.cc"));
    cout << " of this application." << p() << endl;
    
    // Toolbar
    cout << a("Back to form", add("href","/~sbooth/testform.html")) 
	 << " | "
	 << a("Cgicc Documentation", add("href","/~sbooth/index.html"))
	 << " | " 
	 << a("Alphabetic Index of Classes", 
	      add("href","/~sbooth/aindex.html"))
	 << " | " 
	 << a("Class Hierarchy",add("href","/~sbooth/HIER.html")) 
	 << endl;
    
    // End of document
    cout << div_() << endl;
    cout << body() << html() << endl;
    
    return EXIT_SUCCESS;
  }
}

// Print out a table of the CgiEnvironment
void
dumpEnvironment(const CgiEnvironment *env) {

  // This is just a brain-dead dump of information.
  // Almost all of this code is for HTML formatting
  cout << h2() << "Environment information from "
       << a("CgiEnvironment", add("href","/~sbooth/CgiEnvironment.html"))
       << h2() << endl;
  
  cout << div_(add("align","center")) << endl;
  
  cout << table(add("border","0").add("rules","none").add("frame","void")
		.add("cellspacing","2").add("cellpadding","2")
		.add("class","cgi")) << endl;
  cout << colgroup(add("span","2")) << endl;
  cout << col(add("align","center").add("class","title").add("span","1")) 
       << endl;
  cout << col(add("align","left").add("class","data").add("span","1")) 
       << endl;
  cout << colgroup() << endl;
  
  cout << tr() << td("Request Method", add("class","title")) 
       << td(env->getRequestMethod(), add("class","data")) << tr() << endl;
  cout << tr() << td("Path Info", add("class","title")) 
       << td(env->getPathInfo(), add("class","data")) << tr() << endl;
  cout << tr() << td("Path Translated", add("class","title")) 
       << td(env->getPathTranslated(), add("class","data")) << tr() << endl;
  cout << tr() << td("Script Name", add("class","title")) 
       << td(env->getScriptName(), add("class","data")) << tr() << endl;
  cout << tr() << td("HTTP Referrer", add("class","title")) 
       << td(env->getReferrer(), add("class","data")) << tr() << endl;
  cout << tr() << td("HTTP Cookie", add("class","title")) 
       << td(env->getCookies(), add("class","data")) << tr() << endl;
  cout << tr() << td("Query String", add("class","title")) 
       << td(env->getQueryString(), add("class","data")) << tr() << endl;
  cout << tr() << td("Content Length", add("class","title")) 
       << td(add("class","data")) << env->getContentLength() 
       << td() << tr() << endl;
  cout << tr() << td("Post Data", add("class","title")) 
       << td(add("class","data")) 
       << pre(env->getPostData(), add("class","data")) << td() 
       << tr() << endl;
  cout << tr() << td("Remote Host", add("class","title")) 
       << td(env->getRemoteHost(), add("class","data")) << tr() << endl;
  cout << tr() << td("Remote Address", add("class","title")) 
       << td(env->getRemoteAddr(), add("class","data")) << tr() << endl;
  cout << tr() << td("Authorization Type", add("class","title")) 
       << td(env->getAuthType(), add("class","data")) << tr() << endl;
  cout << tr() << td("Remote User", add("class","title")) 
       << td(env->getRemoteUser(), add("class","data")) << tr() << endl;
  cout << tr() << td("Remote Identification", add("class","title")) 
       << td(env->getRemoteIdent(), add("class","data")) << tr() << endl;
  cout << tr() << td("Content Type", add("class","title")) 
       << td(env->getContentType(), add("class","data")) << tr() << endl;
  cout << tr() << td("HTTP Accept", add("class","title")) 
       << td(env->getAccept(), add("class","data")) << tr() << endl;
  cout << tr() << td("User Agent", add("class","title")) 
       << td(env->getUserAgent(), add("class","data")) << tr() << endl;
  cout << tr() << td("Server Software", add("class","title")) 
       << td(env->getServerSoftware(), add("class","data")) << tr() << endl;
  cout << tr() << td("Server Name", add("class","title")) 
       << td(env->getServerName(), add("class","data")) << tr() << endl;
  cout << tr() << td("Gateway Interface", add("class","title")) 
       << td(env->getGatewayInterface(), add("class","data")) << tr() << endl;
  cout << tr() << td("Server Protocol", add("class","title")) 
       << td(env->getServerProtocol(), add("class","data")) << tr() << endl;
  cout << tr() << td("Server Port", add("class","title")) 
       << td(add("class","data")) << env->getServerPort() 
       << td() << tr() << endl;
  cout << tr() << td("Redirect Request", add("class","title")) 
       << td(env->getRedirectRequest(),add("class","data")) << tr() << endl;
  cout << tr() << td("Redirect URL", add("class","title")) 
       << td(env->getRedirectURL(), add("class","data")) << tr() << endl;
  cout << tr() << td("Redirect Status", add("class","title")) 
       << td(env->getRedirectStatus(), add("class","data")) << tr() << endl;
  
  cout << table() << div_() << endl;
}

// Print out the value of every form element
void
dumpList(const Cgicc *formData) {
  cout << h2() << "Form Data via "
       << a("LinkedList", add("href","/~sbooth/LinkedList.html"))
       << h2() << endl;
  
  cout << div_(add("align","center")) << endl;
  
  cout << table(add("border","0").add("rules","none").add("frame","void")
		.add("cellspacing","2").add("cellpadding","2")
		.add("class","cgi")) << endl;
  cout << colgroup(add("span","2")) << endl;
  cout << col(add("align","center").add("span","2")) << endl;
  cout << colgroup() << endl;
  
  cout << tr(add("class","title")) << td("Element Name") 
       << td("Element Value") << tr() << endl;
  
  // Iterate through the linked list, and print out each value
  LinkedList<FormEntry>::ConstIterator iter = (**formData).begin();
  while(iter.isValid()) {
    cout << tr(add("class","data")) << td((*iter).getName()) 
	 << td((*iter).getValue()) << tr() << endl;
    *iter++;
  }
  cout << table() << div_() << endl;
}

// Print out information customized for each element
void
showForm(const Cgicc *formData) {

  // I am using an if statement to check if each element is found
  cout << h2() << "Form Data via "
       << a("Cgicc" ,add("href","/~sbooth/Cgic.html"))
       << h2() << endl;
  
  cout << div_(add("class","notice")) << endl;

  //getElement
  LinkedList<FormEntry>::ConstIterator name = formData->getElement("name");
  if(name.isValid() && ! (*name).isEmpty())
    cout << "Your name is " << **name << '.' << br() << endl;
  else
    cout << "You don't have a name." << br() << endl;

  // getElement and getDoubleValue
  LinkedList<FormEntry>::ConstIterator salary = formData->getElement("bucks");
  if(salary.isValid() && ! (*salary).isEmpty())
    cout << "You make " << (*salary).getDoubleValue(80, 120) 
	 << " million dollars." << br() << endl;
  else
    cout << "You don't have a salary." << br() << endl;

  // getElement and getIntegerValue
  LinkedList<FormEntry>::ConstIterator hours = formData->getElement("time");
  if(hours.isValid() && ! (*hours).isEmpty())
    cout << "You've wasted " << (*hours).getIntegerValue() 
	 << " hours on the web." << br() << endl;
  else
    cout << "You haven't wasted any time on the web." << br() << endl;

  // getElement and getStrippedValue
  LinkedList<FormEntry>::ConstIterator sheep = formData->getElement("sheep");
  if(sheep.isValid() && ! (*sheep).isEmpty()) {
    char *temp;
    (*sheep).getStrippedValue(temp);
    cout << "Your thoughts about sheep cloning: " << temp << br() << endl;
    delete [] temp;
  }
  else
    cout << "You don't have any thoughts about sheep!?" << br() << endl;
  
  // queryCheckbox
  if(formData->queryCheckbox("hungry"))
    cout << "You are hungry." << br() << endl;
  else
    cout << "You are not hungry." << br() << endl;

  // getElementMultiple
  LinkedList<FormEntry> flavors;
  formData->getElementMultiple("flavors", flavors);
  if(! flavors.isEmpty()) {
    cout << "You like ";
    for(int i = 0; i < flavors.length(); i++) {
      cout << (*(flavors[i])).getValue();
      if(i < flavors.length() - 2)
	cout << ", ";
      else if(i == flavors.length() - 2)
	cout << " and ";
    }
    cout << " ice cream." << br() << endl;
  }
  else
    cout << "You don't like ice cream!?" << br() << endl;
  
  // getElement
  LinkedList<FormEntry>::ConstIterator hair = formData->getElement("hair");
  if(hair.isValid())
    cout << "Your hair is " << **hair << '.' << br() << endl;
  else
    cout << "You don't have any hair." << br() << endl;
  
  LinkedList<FormEntry>::ConstIterator vote = formData->getElement("vote");
  if(vote.isValid())
    cout << "You voted for " << **vote << '.' << br() << endl;
  else
    cout << "This should never happen. ERROR!" << br() << endl;
  
  // getElementMultiple
  LinkedList<FormEntry> friends;
  formData->getElementMultiple("friends", friends);
  if(! friends.isEmpty()) {
    cout << "You like ";
    for(int i = 0; i < friends.length(); i++) {
      cout << (*(friends[i])).getValue();
      if(i < friends.length() - 2)
	cout << ", ";
      else if(i == friends.length() - 2)
	cout << " and ";
    }
    cout << " on Friends." << br() << endl;
  }
  else
    cout << "You don't watch Friends!?" << br() << endl;
  
  cout << div_() << endl;
}

// Show the uploaded file
// This will work if you uncomment the appropriate lines in testform.html
void
showFile(const Cgicc *formData) {
  cout << h2() << "File Uploaded via "
       << a("FormFile",add("href","/~sbooth/FormFile.html"))
       << h2() << endl;
  const FormFile *file = (FormFile*) formData->findEntryByName("userfile");
  if(file != NULL) {
    cout << div_(add("align","center")) << endl;
    
    cout << table(add("border","0").add("rules","none").add("frame","void")
		  .add("cellspacing","2").add("cellpadding","2")
		  .add("class","cgi")) << endl;
    cout << colgroup(add("span","2")) << endl;
    cout << col(add("align","center").add("class","title").add("span","1")) 
	 << endl;
    cout << col(add("align","left").add("class","data").add("span","1")) 
	 << endl;
    cout << colgroup() << endl;
    
    cout << tr() << td("Name", add("class","title"))
	 << td(file->getName(), add("class","data3")) << tr() << endl;
    cout << tr() << td("Data Type", add("class","title"));
    bool isImage = false;
    if(file->getDataType() != NULL) {
      if(stringsAreEqual("image",file->getDataType(),strlen("image"),true))
	isImage = true;
      cout << td(file->getDataType(), add("class","data3")) << tr() << endl;
    }
    else
      cout << td("[unknown]", add("class","data3")) << tr() << endl;
    cout << tr() << td("Filename", add("class","title")) 
	 << td(file->getFilename(), add("class","data3")) << tr() << endl;
    cout << tr() << td("Data Length", add("class","title")) 
	 << td(add("class","data3")) << file->getDataLength() 
	 << td() << tr() << endl;
    
    if(isImage) {
      ofstream temp("/usr/home/sbooth/public_html/temp");
      cout << tr() << td("File Data", add("class","title"))
	   << td(add("class","data2")) << "<IMG SRC=\"/~sbooth/temp\">";
      file->writeToStream(temp);
      cout << td() << tr() << endl;
    }
    else {
      cout << tr() << td("File Data", add("class","title"))
	   << td(add("class","data2")) << pre();
      file->writeToStream(cout);
      cout << pre() << td() << tr() << endl;
    }
    
    cout << table() << div_() << endl;
  }
  else {
    cout << p() << div_(add("class", "notice")) << endl;
    cout << "No file was uploaded." << endl << div_() << p() << endl;
  }
}
